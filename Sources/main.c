/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <string.h> // strlen()
#include "stm32f446xx.h"
#include "stm32f446xx_gpio_driver.h"
#include "stm32f446xx_uart_driver.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/* --- Global Variables --- */
USART_Handle_t USART2_Handle; // declared here to reuse in USART_SendData in main() function
uint8_t message = 0; // data collected from USART2 data register

void hardware_setup(void){
	/*
	 * ========================================
	 * 		    Clock Configuration
	 * ========================================
	 */
	GPIOA_PCLK_EN();
	USART2_PCLK_EN();

	/*
	 * ========================================
	 * 		PA5 (Red) Configuration
	 * ========================================
	 */
	GPIO_Handle_t LED_RED;

	LED_RED.pGPIOx = GPIOA;

	LED_RED.GPIO_PinConfig.GPIO_PinNumber = 5;
	LED_RED.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	LED_RED.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP; // Push Pull (default)
	LED_RED.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD; // the voltage output will be locked by STM32
															   // It will NOT float even without pull-up resistors
	LED_RED.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_MEDIUM;

	GPIO_Init(&LED_RED);

	/*
	 * ========================================
	 * 		PA6 (Green) Configuration
	 * ========================================
	 */
	GPIO_Handle_t LED_GREEN;

	LED_GREEN.pGPIOx = GPIOA;

	LED_GREEN.GPIO_PinConfig.GPIO_PinNumber = 6;
	LED_GREEN.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	LED_GREEN.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP; // Push Pull (default)
	LED_GREEN.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD; // the voltage output will be locked by STM32
															   // It will NOT float even without pull-up resistors
	LED_GREEN.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_MEDIUM;

	GPIO_Init(&LED_GREEN);
	/*
	 * ========================================
	 * 		PA7 (Blue) Configuration
	 * ========================================
	 */
	GPIO_Handle_t LED_BLUE;

	LED_BLUE.pGPIOx = GPIOA;

	LED_BLUE.GPIO_PinConfig.GPIO_PinNumber = 7;
	LED_BLUE.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
	LED_BLUE.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP; // Push Pull (default)
	LED_BLUE.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD; // the voltage output will be locked by STM32
															   // It will NOT float even without pull-up resistors
	LED_BLUE.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_MEDIUM;

	GPIO_Init(&LED_BLUE);

	/* ---------- USART2 Configuration ----------*/

	/*
	 * ========================================
	 * 		PA2 (TX) Configuration
	 * ========================================
	 * according to Table 11. Alternate function at page 57 in datasheet
	 * when PA2 is set to AF7
	 * it can use USART2_TX
	 */
	GPIO_Handle_t USART2_TX;

	USART2_TX.pGPIOx = GPIOA;
	USART2_TX.GPIO_PinConfig.GPIO_PinNumber = 2;
	USART2_TX.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTN;
	USART2_TX.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_VERY_HIGH;
	USART2_TX.GPIO_PinConfig.GPIO_PinAltFunMode = GPIO_AF_7 ;
	USART2_TX.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU; // pull-up
	USART2_TX.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP; // default

	GPIO_Init(&USART2_TX);

	/*
	 * ========================================
	 * 		PA3 (RX) Configuration
	 * ========================================
	 * when PA3 is set to AF7
	 * it can use USART2_RX
	 *
	 * --------------- NOTE ---------------
	 * Both TX/RX are configured with internal pull-ups to ensure the line remains
	 * in a stable IDLE (High) state. This avoids floating-point noise that might
	 * be misinterpreted as a START bit (Low), preventing the receiver from
	 * sampling garbage data.
	 */
	GPIO_Handle_t USART2_RX;

	USART2_RX.pGPIOx = GPIOA;
	USART2_RX.GPIO_PinConfig.GPIO_PinNumber = 3;
	USART2_RX.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTN;
	USART2_RX.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_VERY_HIGH;
	USART2_RX.GPIO_PinConfig.GPIO_PinAltFunMode = GPIO_AF_7 ;
	USART2_RX.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU; // pull-up
	USART2_RX.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP; // default

	GPIO_Init(&USART2_RX);

	/*
	 * ========================================
	 * 		USART2 Configuration
	 * ========================================
	 * since I only use it for testing purposes (Serial Print)
	 * and giving command to turn the motor from my end
	 * I use the standard "8-N-1" setup
	 * 1. 8 bits as word length (not 9 since I will not use parity)
	 * 2. None parity (unless signal is not stable, it is not needed)
	 * 3. Stop Bits -> 1 (not too fast, not too slow, right in the middle)
	 */
	USART2_Handle.pUSARTx = USART2;
	USART2_Handle.USART_Config.USART_MODE = USART_MODE_TXRX;
	USART2_Handle.USART_Config.USART_WordLength = USART_WordLength_8;
	USART2_Handle.USART_Config.USART_ParityControl = USART_Parity_DISABLE;
	USART2_Handle.USART_Config.USART_StopBits = USART_StopBits_1;
	USART2_Handle.USART_Config.USART_Baud = USART_Baud_115200;

	USART_Init(&USART2_Handle);

	/*
	 * ==============================
	 * USART2 Interrupt Set Up
	 * ==============================
	 * Reference: Table 163. USART interrupt requests
	 *
	 * In order to use interrupt for USART
	 * [RXNEIE] must be enabled
	 *
	 * Control register 1 (USART_CR1)
	 * Bit 5 RXNEIE: RXNE interrupt enable
	 * 0: Interrupt is inhibited
	 * 1: An USART interrupt is generated whenever ORE=1 or RXNE=1 in the USART_SR register
	 */
	SET_BIT(USART2->CR1, 5);

	/*
	 * ==============================
	 * Enable USART2 (IRQ = 38) -> NVIC
	 * ==============================
	 */
	USART_IRQInterruptConfig(USART2_IRQ , ENABLE);

	/*
	 * ========================================
	 * Switch Configuration (Inputs)
	 * ========================================
	 * Using PA10, PA11, PA12 as Switches
	 * Mode: Input
	 * PUPD: Pull-up (So default state is HIGH, press button to go "active LOW")
	 */
	GPIO_Handle_t Switch_a, Switch_b, Switch_c;

	// --- Switch 1 (PA10) ---
	Switch_a.pGPIOx = GPIOA;
	Switch_a.GPIO_PinConfig.GPIO_PinNumber = 10;
	Switch_a.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN ;
	Switch_a.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU; // pull-up enabled to avoid bad readings due to floating state
	Switch_a.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_MEDIUM;

	// --- Switch 2 (PA11) ---
	Switch_b.pGPIOx = GPIOA;
	Switch_b.GPIO_PinConfig.GPIO_PinNumber = 11;
	Switch_b.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN ;
	Switch_b.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU; // pull-up enabled to avoid bad readings due to floating state
	Switch_b.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_MEDIUM;

	// --- Switch 3 (PA12) ---
	Switch_c.pGPIOx = GPIOA;
	Switch_c.GPIO_PinConfig.GPIO_PinNumber = 12;
	Switch_c.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IN ;
	Switch_c.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PIN_PU; // pull-up enabled to avoid bad readings due to floating state
	Switch_c.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_MEDIUM;

	GPIO_Init(&Switch_a);
	GPIO_Init(&Switch_b);
	GPIO_Init(&Switch_c);
}

/*
 * ==========================================
 * Interrupt Service Routine (ISR) for USART2
 * ==========================================
 * This function handles the Hardware Interrupt triggered by USART2
 *
 * KEY CONCEPT:
 * Unlike standard C functions, this is NOT called by main().
 * It is invoked directly by the Hardware (NVIC) via the Vector Table
 * when the specific interrupt event occurs.
 */
void USART2_IRQHandler(void){
	/*
	 * there is no pending register to manually clear
	 * since USART interrupt does NOT go through EXTI
	 *
	 * Also, in SR (Status Register)
	 * Bit 5 RXNE: Read data register not empty
	 * It says:
	 * [This bit is set by hardware when the content of the RDR shift register
	 * has been transferred to the USART_DR register. An interrupt is generated
	 * if RXNEIE=1 in the USART_CR1 register.
	 * It is cleared by a read to the USART_DR register.]
	 * ->
	 * this tells us that, the hardware will automatically reset this register
	 * once the data in Data Register is read, so we do not need to manually reset it
	 *
	 * [READ ONLY!]
	 * Reading DR automatically clears the RXNE flag.
	*/
	message = ( (USART2->DR) & 0xFF );

	/*
	 * [Commented Out] because:
	 * DR is meant for both TX and RX
	 * it is both the RDR (receive data register) and TDR (transmit data register)
	 * overwriting it manually each time after the it receives a byte
	 * might cause it to accidentally transmit a byte
	 */
	// USART2->DR = 0;
}

/*
 * ------------------------------
 * 		Generic LED Control
 * ------------------------------
 *
 */
void Set_LED(uint8_t pinNumber, uint8_t status, char* colorName){
	if (status == ENABLE){
		GPIO_WriteToOutputPin(GPIOA, pinNumber, ENABLE);

		USART_SendData(&USART2_Handle, (uint8_t*)colorName, strlen(colorName));
		USART_SendData(&USART2_Handle, (uint8_t*)" ON\r\n", strlen(" ON\r\n"));
	} else {
		GPIO_WriteToOutputPin(GPIOA, pinNumber, DISABLE);

		USART_SendData(&USART2_Handle, (uint8_t*)colorName, strlen(colorName));
		USART_SendData(&USART2_Handle, (uint8_t*)" OFF\r\n", strlen(" OFF\r\n"));
	}
}

/*
 * ------------------------------
 * 		Generic Switch Read
 * ------------------------------
 *
 */
void Read_Switch(uint8_t pinNumber, char* switchName){
	uint8_t state = GPIO_ReadFromInputPin(GPIOA, pinNumber);
	if (state == 0){ // "active low" since default state is HIGH due to pull-up resistor
		USART_SendData(&USART2_Handle, (uint8_t*)switchName, strlen(switchName));
		USART_SendData(&USART2_Handle, (uint8_t*)" Pressed!\r\n", strlen(" Pressed!\r\n"));
	}
	else {
		USART_SendData(&USART2_Handle, (uint8_t*)switchName, strlen(switchName));
		USART_SendData(&USART2_Handle, (uint8_t*)" Released!\r\n", strlen(" Released!\r\n"));
	}

}

/*
 * main loop should execute functions, especially when functions are lots of lines of code
 * such functions should be implemented outside main loop to keep the logic flow simple and clear
 */
void Process_Command(uint8_t message){
	switch (message) {
	/* --- RED LED Control --- */
	case '1': // PA 5
		Set_LED(5, ENABLE, "Red");
		break;
	case '2':
		Set_LED(5, DISABLE, "Red");
		break;

	/* --- GREEN LED Control --- */
	case '3':
		Set_LED(6, ENABLE, "Green");
		break;
	case '4':
		Set_LED(6, DISABLE, "Green");
		break;

	/* --- BLUE LED Control --- */
	case '5':
		Set_LED(7, ENABLE, "Blue");
		break;
	case '6':
		Set_LED(7, DISABLE, "Blue");
		break;

	/* --- ALL LEDs ON --- */
	case '7':
		Set_LED(5, ENABLE, "Red");
		Set_LED(6, ENABLE, "Green");
		Set_LED(7, ENABLE, "Blue");
		break;

	/* --- ALL LEDs OFF --- */
	case '8':
		Set_LED(5, DISABLE, "Red");
		Set_LED(6, DISABLE, "Green");
		Set_LED(7, DISABLE, "Blue");
		break;

	/* --- READ Switch a --- */
	case 'a':
		Read_Switch(10, "Switch A");
		break;

	/* --- READ Switch b --- */
	case 'b':
		Read_Switch(11, "Switch B");
		break;

	/* --- READ Switch c --- */
	case 'c':
		Read_Switch(12, "Switch C");
		break;

	/* --- READ All Switches --- */
	case 'd':
		Read_Switch(10, "Switch A");
		Read_Switch(11, "Switch B");
		Read_Switch(12, "Switch C");
		break;
	default:
		USART_SendData(&USART2_Handle, (uint8_t*)"Error. Unknown Command.\r\n", strlen("Error. Unknown Command.\r\n"));
		break;
	}
}

int main(void)
{
	hardware_setup();

	for (int i = 0; i < 5000000; i++); // software delay to avoid bad data at reboot

	USART_SendData(&USART2_Handle, (uint8_t*)"\r\n", 2);

	const char* intro_msg =
			" ---------- System Ready! ----------\r\n"
			"1: Red ON                           \r\n"
			"2: Red OFF                          \r\n"
			"3: Green ON                         \r\n"
			"4: Green OFF                        \r\n"
			"5: Blue ON                          \r\n"
			"6: Blue OFF                         \r\n"
			"7: ALL LEDs ON                      \r\n"
			"8: ALL LEDs OFF                     \r\n"
			"a: Read Switch A                    \r\n"
			"b: Read Switch B                    \r\n"
			"c: Read Switch C                    \r\n"
			"d: Read ALL Switches                \r\n";
	USART_SendData(&USART2_Handle, (uint8_t*)intro_msg, strlen(intro_msg));

	while (1) {
		// only take actions when there is data
		if (message != 0){
			uint8_t temp = message; // 1. Read -> Copy Command Data
			message = 0; // 2. Clear -> reset the buffer, otherwise while(1) will end up in a dead loop
			Process_Command(temp); // 3. Process -> Handle the command
		}
	}
}
